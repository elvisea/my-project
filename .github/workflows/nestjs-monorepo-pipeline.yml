# Nome do pipeline que aparecerá na interface do GitHub Actions
name: NestJS Monorepo CI/CD Pipeline

# Define quando o pipeline será executado
on:
  push:
    branches: [ main, develop ]  # Executa quando há push nestas branches
  pull_request:
    branches: [ main, develop ]  # Executa quando há PR para estas branches

# Variáveis de ambiente globais disponíveis para todos os jobs
env:
  REGISTRY: ghcr.io                    # Registry do GitHub para armazenar imagens Docker
  IMAGE_NAME: ${{ github.repository }} # Nome do repositório atual (formato: usuario/repo)

# Lista de jobs que serão executados
jobs:
  # Job de verificação de qualidade do código
  quality:
    name: Quality Check
    runs-on: ubuntu-latest    # Executa em uma máquina Ubuntu mais recente
    
    steps:
      # Faz checkout do código na máquina do runner
      - name: Checkout Repository
        uses: actions/checkout@v4

      # Configura o Node.js no ambiente
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'        # Habilita cache para dependências npm

      # Instala as dependências do projeto
      - name: Install Dependencies
        run: npm ci           # Usa npm ci para instalação limpa e determinística

      # Executa o linter para verificar qualidade do código
      - name: Run ESLint
        run: npm run lint

      # Verifica tipos TypeScript
      - name: Check Types
        run: npm run build

  # Job de execução de testes
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: quality           # Só executa se o job quality passar

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci

      # Executa testes unitários
      - name: Run Unit Tests
        run: npm run test

      # Executa testes end-to-end
      - name: Run E2E Tests
        run: npm run test:e2e

  # Job de build das aplicações
  build:
    name: Build Applications
    runs-on: ubuntu-latest
    needs: test             # Só executa se o job test passar
    env:
      # Define nomes das imagens Docker com tag baseada no SHA do commit
      MY_APP_IMAGE: my-app:${{ github.sha }}
      MY_PROJECT_IMAGE: my-project:${{ github.sha }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci

      # Compila as aplicações
      - name: Build My App
        run: npm run build my-app

      - name: Build My Project
        run: npm run build my-project

      # Configura QEMU para build multi-plataforma
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      # Configura Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Faz login no GitHub Container Registry
      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Constrói e publica a imagem Docker do my-app
      - name: Build My App Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/my-app/Dockerfile
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/my-app:latest,${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/my-app:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Constrói e publica a imagem Docker do my-project
      - name: Build My Project Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/my-project/Dockerfile
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/my-project:latest,${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/my-project:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Job de deploy para produção
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build            # Só executa se o job build passar
    if: github.ref == 'refs/heads/main'  # Só executa se for na branch main
    environment: production # Define o ambiente como produção

    env:
      DOCKER_COMPOSE_FILE: docker-compose.prod.yml

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      # Configura a chave SSH para acesso ao servidor
      - name: Create SSH key
        run: |
          mkdir -p ~/.ssh/
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.REMOTE_HOST }} >> ~/.ssh/known_hosts

      # Transfere o arquivo docker-compose.prod.yml para o servidor
      - name: Transfer Docker Compose File
        run: |
          scp -i ~/.ssh/deploy_key -P ${{ secrets.REMOTE_PORT }} \
              ${{ env.DOCKER_COMPOSE_FILE }} \
              ${{ secrets.REMOTE_USER }}@${{ secrets.REMOTE_HOST }}:${{ secrets.REMOTE_TARGET }}

      # Executa o deploy no servidor remoto
      - name: Deploy to Server
        run: |
          ssh -i ~/.ssh/deploy_key -p ${{ secrets.REMOTE_PORT }} ${{ secrets.REMOTE_USER }}@${{ secrets.REMOTE_HOST }} "\
            cd ${{ secrets.REMOTE_TARGET }} && \
            echo \"REGISTRY=${{ env.REGISTRY }}\" > .env && \
            echo \"IMAGE_NAME=${{ env.IMAGE_NAME }}\" >> .env && \
            echo \"GITHUB_SHA=${{ github.sha }}\" >> .env && \
            docker login ${{ env.REGISTRY }} -u ${{ github.actor }} -p ${{ secrets.GITHUB_TOKEN }} && \
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} pull && \
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} up -d"

      # Limpa a chave SSH por segurança
      - name: Cleanup
        if: always()        # Executa mesmo se houver falha
        run: rm -f ~/.ssh/deploy_key