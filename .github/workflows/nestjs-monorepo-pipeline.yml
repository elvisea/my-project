# Nome do pipeline que aparecerá na interface do GitHub Actions
name: NestJS Monorepo CI/CD Pipeline

# Define quando o pipeline será executado
on:
  push:
    branches: [ main, develop ]
    paths:
      - 'apps/**'
      - 'package.json'
      - 'package-lock.json'
      - '.github/workflows/**'
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'apps/**'
      - 'package.json'
      - 'package-lock.json'
      - '.github/workflows/**'

# Variáveis de ambiente globais disponíveis para todos os jobs
env:
  REGISTRY: ghcr.io                    # Registry do GitHub para armazenar imagens Docker
  IMAGE_NAME: ${{ github.repository }} # Nome do repositório atual (formato: usuario/repo)

# Lista de jobs que serão executados
jobs:
  changes:
    runs-on: ubuntu-latest
    outputs:
      my-app: ${{ steps.filter.outputs.my-app }}
      my-project: ${{ steps.filter.outputs.my-project }}
      shared: ${{ steps.filter.outputs.shared }}
    
    steps:
      - uses: actions/checkout@v4
      
      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            my-app:
              - 'apps/my-app/**'
            my-project:
              - 'apps/my-project/**'
            shared:
              - 'package.json'
              - 'package-lock.json'
              - 'tsconfig.json'
              - 'nest-cli.json'

  # Job de verificação de qualidade do código
  quality:
    name: Quality Check
    runs-on: ubuntu-latest    # Executa em uma máquina Ubuntu mais recente
    needs: changes
    if: ${{ needs.changes.outputs.my-app == 'true' || needs.changes.outputs.my-project == 'true' || needs.changes.outputs.shared == 'true' }}
    
    steps:
      # Faz checkout do código na máquina do runner
      - name: Checkout Repository
        uses: actions/checkout@v4

      # Configura o Node.js no ambiente
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'        # Habilita cache para dependências npm

      # Instala as dependências do projeto
      - name: Install Dependencies
        run: npm ci           # Usa npm ci para instalação limpa e determinística

      # Executa o linter para verificar qualidade do código
      - name: Run ESLint
        run: npm run lint

      # Verifica tipos TypeScript
      - name: Check Types
        run: npm run build

  # Job de execução de testes
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: [changes, quality]
    if: ${{ needs.changes.outputs.my-app == 'true' || needs.changes.outputs.my-project == 'true' || needs.changes.outputs.shared == 'true' }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci

      # Executa testes unitários
      - name: Run Unit Tests
        run: npm run test

      # Executa testes end-to-end
      - name: Run E2E Tests
        run: npm run test:e2e

  # Job de build das aplicações
  build-my-app:
    needs: [changes, test]
    if: ${{ needs.changes.outputs.my-app == 'true' || needs.changes.outputs.shared == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci

      # Compila as aplicações
      - name: Build My App
        run: npm run build my-app

      # Configura QEMU para build multi-plataforma
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      # Configura Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Faz login no GitHub Container Registry
      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Constrói e publica a imagem Docker do my-app
      - name: Build My App Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/my-app/Dockerfile
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/my-app:latest,${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/my-app:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  build-my-project:
    needs: [changes, test]
    if: ${{ needs.changes.outputs.my-project == 'true' || needs.changes.outputs.shared == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci

      # Compila as aplicações
      - name: Build My Project
        run: npm run build my-project

      # Configura QEMU para build multi-plataforma
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      # Configura Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Faz login no GitHub Container Registry
      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Constrói e publica a imagem Docker do my-project
      - name: Build My Project Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/my-project/Dockerfile
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/my-project:latest,${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/my-project:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Job de deploy para produção
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-my-app, build-my-project]
    if: github.ref == 'refs/heads/main'  # Só executa se for na branch main
    environment: production # Define o ambiente como produção

    env:
      DOCKER_COMPOSE_FILE: docker-compose.prod.yml

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      # Configura a chave SSH para acesso ao servidor
      - name: Create SSH key
        run: |
          mkdir -p ~/.ssh/
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.REMOTE_HOST }} >> ~/.ssh/known_hosts

      # Transfere o arquivo docker-compose.prod.yml para o servidor
      - name: Transfer Docker Compose File
        run: |
          scp -i ~/.ssh/deploy_key -P ${{ secrets.REMOTE_PORT }} \
              ${{ env.DOCKER_COMPOSE_FILE }} \
              ${{ secrets.REMOTE_USER }}@${{ secrets.REMOTE_HOST }}:${{ secrets.REMOTE_TARGET }}

      # Executa o deploy no servidor remoto
      - name: Deploy to Server
        run: |
          ssh -i ~/.ssh/deploy_key -p ${{ secrets.REMOTE_PORT }} ${{ secrets.REMOTE_USER }}@${{ secrets.REMOTE_HOST }} "\
            cd ${{ secrets.REMOTE_TARGET }} && \
            echo \"REGISTRY=${{ env.REGISTRY }}\" > .env && \
            echo \"IMAGE_NAME=${{ env.IMAGE_NAME }}\" >> .env && \
            echo \"GITHUB_SHA=${{ github.sha }}\" >> .env && \
            docker login ${{ env.REGISTRY }} -u ${{ github.actor }} -p ${{ secrets.GITHUB_TOKEN }} && \
            ${needs.changes.outputs.my-app == 'true' || needs.changes.outputs.shared == 'true' && 'docker compose -f docker-compose.prod.yml pull my-app && docker compose -f docker-compose.prod.yml up -d my-app'} && \
            ${needs.changes.outputs.my-project == 'true' || needs.changes.outputs.shared == 'true' && 'docker compose -f docker-compose.prod.yml pull my-project && docker compose -f docker-compose.prod.yml up -d my-project'}"

      # Limpa a chave SSH por segurança
      - name: Cleanup
        if: always()        # Executa mesmo se houver falha
        run: rm -f ~/.ssh/deploy_key