# Nome do pipeline que aparecerá na interface do GitHub Actions
name: NestJS CI/CD Pipeline

# Define quando o pipeline será executado
on:
  push:
    branches: [ main, develop ]
    paths:
      - 'src/**'                      # A pasta src do projeto
      - 'package.json'
      - 'package-lock.json'
      - '.github/workflows/**'
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'src/**'
      - 'package.json'
      - 'package-lock.json'
      - '.github/workflows/**'

# Variáveis de ambiente globais disponíveis para todos os jobs
env:
  REGISTRY: ghcr.io                    # Registry do GitHub para armazenar imagens Docker
  IMAGE_NAME: ${{ github.repository }}  # Nome do repositório atual (formato: usuario/repo)
  POSTGRES_USER: ${{ secrets.POSTGRES_USER }}  # Variáveis para banco de dados
  POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
  POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
  POSTGRES_PORT: ${{ secrets.POSTGRES_PORT }}
  POSTGRES_HOST: ${{ secrets.POSTGRES_HOST }}
  DATABASE_URL: postgresql://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@postgres:${{ secrets.POSTGRES_PORT }}/${{ secrets.POSTGRES_DB }}
  PORT_BARBER_MASTER: ${{ secrets.PORT_BARBER_MASTER }}  # Porta da aplicação

# Lista de jobs que serão executados
jobs:
  changes:
    runs-on: ubuntu-latest
    outputs:
      code: ${{ steps.filter.outputs.code }}  # Verificando alterações no código
    steps:
      - uses: actions/checkout@v4

      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            code:
              - 'src/**'
            pipeline:
              - '.github/workflows/nestjs-pipeline.yml'  # Verificando alterações no pipeline

  # Job de verificação de qualidade do código
  quality:
    name: Quality Check
    runs-on: ubuntu-latest
    needs: changes
    if: ${{ needs.changes.outputs.code == 'true' }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci

      - name: Run ESLint
        run: npm run lint

      - name: Check Types
        run: npm run build

  # Job de execução de testes
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: [changes, quality]
    if: ${{ needs.changes.outputs.code == 'true' }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci

      - name: Run Unit Tests
        run: npm run test -- --passWithNoTests

      - name: Run E2E Tests
        run: npm run test:e2e -- --passWithNoTests

  # Job de build da aplicação
  build:
    name: Build Project
    needs: [changes, test]
    if: ${{ needs.changes.outputs.code == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci

      - name: Build Project
        run: npm run build

      # Configura QEMU para build multi-plataforma
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      # Configura Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Faz login no GitHub Container Registry
      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Constrói e publica a imagem Docker
      - name: Build Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile  # Supondo que o Dockerfile esteja na raiz
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest,${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Job de deploy para produção
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [changes, build]
    if: github.ref == 'refs/heads/main' && needs.changes.outputs.code == 'true'
    environment: production
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create SSH key
        run: |
          mkdir -p ~/.ssh/
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.REMOTE_HOST }} >> ~/.ssh/known_hosts

      - name: Transfer Docker Compose File
        run: |
          scp -i ~/.ssh/deploy_key -P ${{ secrets.REMOTE_PORT }} \
            docker-compose.prod.yml \
            ${{ secrets.REMOTE_USER }}@${{ secrets.REMOTE_HOST }}:${{ secrets.REMOTE_TARGET }}

      - name: Deploy to Server
        run: |
          ssh -i ~/.ssh/deploy_key -p ${{ secrets.REMOTE_PORT }} ${{ secrets.REMOTE_USER }}@${{ secrets.REMOTE_HOST }} "\
            cd ${{ secrets.REMOTE_TARGET }} && \
            docker login ${{ env.REGISTRY }} -u ${{ github.actor }} -p ${{ secrets.GITHUB_TOKEN }} && \
            docker compose -f docker-compose.prod.yml pull && \
            docker compose -f docker-compose.prod.yml up -d"

      - name: Cleanup
        if: always()
        run: rm -f ~/.ssh/deploy_key
